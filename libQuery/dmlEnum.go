// Code generated by "enumer -type=DmlCommandType -json -output dmlEnum.go"; DO NOT EDIT.

package libQuery

import (
	"encoding/json"
	"fmt"
	"strings"
)

const _DmlCommandTypeName = "QueryCheckNotExistsQueryCheckExistsInsertUpdateDelete"

var _DmlCommandTypeIndex = [...]uint8{0, 19, 35, 41, 47, 53}

const _DmlCommandTypeLowerName = "querychecknotexistsquerycheckexistsinsertupdatedelete"

func (i DmlCommandType) String() string {
	if i < 0 || i >= DmlCommandType(len(_DmlCommandTypeIndex)-1) {
		return fmt.Sprintf("DmlCommandType(%d)", i)
	}
	return _DmlCommandTypeName[_DmlCommandTypeIndex[i]:_DmlCommandTypeIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _DmlCommandTypeNoOp() {
	var x [1]struct{}
	_ = x[QueryCheckNotExists-(0)]
	_ = x[QueryCheckExists-(1)]
	_ = x[Insert-(2)]
	_ = x[Update-(3)]
	_ = x[Delete-(4)]
}

var _DmlCommandTypeValues = []DmlCommandType{QueryCheckNotExists, QueryCheckExists, Insert, Update, Delete}

var _DmlCommandTypeNameToValueMap = map[string]DmlCommandType{
	_DmlCommandTypeName[0:19]:       QueryCheckNotExists,
	_DmlCommandTypeLowerName[0:19]:  QueryCheckNotExists,
	_DmlCommandTypeName[19:35]:      QueryCheckExists,
	_DmlCommandTypeLowerName[19:35]: QueryCheckExists,
	_DmlCommandTypeName[35:41]:      Insert,
	_DmlCommandTypeLowerName[35:41]: Insert,
	_DmlCommandTypeName[41:47]:      Update,
	_DmlCommandTypeLowerName[41:47]: Update,
	_DmlCommandTypeName[47:53]:      Delete,
	_DmlCommandTypeLowerName[47:53]: Delete,
}

var _DmlCommandTypeNames = []string{
	_DmlCommandTypeName[0:19],
	_DmlCommandTypeName[19:35],
	_DmlCommandTypeName[35:41],
	_DmlCommandTypeName[41:47],
	_DmlCommandTypeName[47:53],
}

// DmlCommandTypeString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func DmlCommandTypeString(s string) (DmlCommandType, error) {
	if val, ok := _DmlCommandTypeNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _DmlCommandTypeNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to DmlCommandType values", s)
}

// DmlCommandTypeValues returns all values of the enum
func DmlCommandTypeValues() []DmlCommandType {
	return _DmlCommandTypeValues
}

// DmlCommandTypeStrings returns a slice of all String values of the enum
func DmlCommandTypeStrings() []string {
	strs := make([]string, len(_DmlCommandTypeNames))
	copy(strs, _DmlCommandTypeNames)
	return strs
}

// IsADmlCommandType returns "true" if the value is listed in the enum definition. "false" otherwise
func (i DmlCommandType) IsADmlCommandType() bool {
	for _, v := range _DmlCommandTypeValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalJSON implements the json.Marshaler interface for DmlCommandType
func (i DmlCommandType) MarshalJSON() ([]byte, error) {
	return json.Marshal(i.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for DmlCommandType
func (i *DmlCommandType) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("DmlCommandType should be a string, got %s", data)
	}

	var err error
	*i, err = DmlCommandTypeString(s)
	return err
}
